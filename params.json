{"name":"Stochastic Cognition","tagline":"...which is another way of saying that this is where I will be posting random thoughts","body":"## A Question Of Ants\r\n2013 August 1\r\n\r\nI'd like to start off by using some mathematical puzzles about ants as a jumping-off point for discussing different \r\nprogramming approaches.\r\n\r\nIn the May 2013 issue of the Communications of the ACM [CACM, Vol. 56 No. 5, Page 104], [Peter Winkler](http://www.math.dartmouth.edu/~pw/) \r\nposes three questions about the behavior of some idealized ants. The basic ant problem is described in this way in Su, Francis E., et al. [\"Ants on a Stick\"](http://www.math.hmc.edu/funfacts) Math Fun Facts:\r\n\r\n> One hundred ants are dropped on a meter stick. Each ant is travelling either to the left or the right with constant speed 1 meter per minute. When two ants meet, they bounce off each other and reverse direction. When an ant reaches an end of the stick, it falls off.\r\n\r\n> At some point all the ants will have fallen off. The time at which this happens will depend on the initial configuration of the ants.\r\n\r\n> Question: over ALL possible initial configurations, what is the longest amount of time that you would need to wait to guarantee that the stick has no more ants? \r\n\r\nPeter goes on to ask us to calculate the probability that the middle ant of 25 will fall off the stick in the direction it was originally facing. Then he takes the meter stick and bends it into a circle, places 12 ants on it (uniform random distribution) and asks for the probability that after 1 minute they are back to their original starting positions.\r\n\r\nThese questions can be answered without writing a single line of code, but where's the fun in that? Instead, let's consider creating an ant simulator.\r\n\r\n### Purely Procedural\r\nLet's start as simply as possible. We'll use two arrays, one for position and one for direction. Once they've been initialized we can loop over them, updating each ant's position:\r\n\r\n```\r\nfor( int i=0; i < N; i++ ) {\r\n   antPosition[i] += timeStep * antVelocity[i];\r\n}\r\n```\r\n\r\nThe finished program is [SimplestAnts.java](https://github.com/avklein/Ants/blob/master/SimplestAnts.java). When we run it with 6 ants we get output that looks like this (the full output file is [here](https://github.com/avklein/Ants/blob/master/SimplestAnts_random_output_1.txt)).\r\n```\r\nCreated 6 ants with speed +/- 1.0 cm./sec. on a 100 cm. stick\r\n\r\n     initial   initial\r\n Ant position  velocity\r\n  0    10.0    -1.0\r\n  1    13.0     1.0\r\n  2    18.0    -1.0\r\n  3    27.0    -1.0\r\n  4    43.0    -1.0\r\n  5    53.0     1.0\r\n\r\n    Time    Ant positions\r\n    0.0:    10.0  13.0  18.0  27.0  43.0  53.0\r\n    0.5:     9.5  13.5  17.5  26.5  42.5  53.5\r\n    1.0:     9.0  14.0  17.0  26.0  42.0  54.0\r\n    1.5:     8.5  14.5  16.5  25.5  41.5  54.5\r\n    2.0:     8.0  15.0  16.0  25.0  41.0  55.0\r\n    2.5:     7.5  15.5==15.5  24.5  40.5  55.5 <<<< ants 1 and 2 collide\r\n    3.0:     7.0  15.0  16.0  24.0  40.0  56.0\r\n    3.5:     6.5  14.5  16.5  23.5  39.5  56.5\r\n    4.0:     6.0  14.0  17.0  23.0  39.0  57.0\r\n    4.5:     5.5  13.5  17.5  22.5  38.5  57.5\r\n    5.0:     5.0  13.0  18.0  22.0  38.0  58.0\r\n    5.5:     4.5  12.5  18.5  21.5  37.5  58.5\r\n    6.0:     4.0  12.0  19.0  21.0  37.0  59.0\r\n    6.5:     3.5  11.5  19.5  20.5  36.5  59.5\r\n    7.0:     3.0  11.0  20.0==20.0  36.0  60.0 <<<< ants 2 and 3 collide\r\n    7.5:     2.5  10.5  19.5  20.5  35.5  60.5\r\n    8.0:     2.0  10.0  19.0  21.0  35.0  61.0\r\n    8.5:     1.5   9.5  18.5  21.5  34.5  61.5\r\n    9.0:     1.0   9.0  18.0  22.0  34.0  62.0\r\n    9.5:     0.5   8.5  17.5  22.5  33.5  62.5\r\n   10.0:    ----   8.0  17.0  23.0  33.0  63.0 <<<< ant 0 falls off\r\n   10.5:    ----   7.5  16.5  23.5  32.5  63.5      the left edge\r\n. . .\r\n```\r\n\r\n***\r\n\r\n_Coming soon / Work In Progress_\r\n\r\n### Ants as Objects\r\nWhere we discuss the design of the [Ant](https://github.com/avklein/Ants/blob/master/Ant.java) class.\r\n\r\n### When Ants Collide\r\nWhy did the first two programs force the Ants to be placed on whole-number positions?\r\nIt was a trick: since all of the Ants move at 1.0 cm./sec., that placement will cause all Ant collisions to take place on positions 0.5, 1.5, 2.5 ... 99.5, and therefore all collisions will occur 0.5, 1.5, 2.5 ... seconds into the simulation. Bottom line: this allows us to run the simulation with a fixed time step of 0.5 seconds, and to know that we can check for collisions just at the beginning or end of a time step.\r\n\r\nWhat if we allowed the Ants to occupy arbitrary positions? Then we would not be able to use a 0.5-second time step, since some Ants might be much closer. If we wanted to just use the same sort of fixed time step as before, then we'd be stuck using a very tiny time step which would be very wasteful of machine resources. A better approach is to use a variable time step. In fact, in this world of uniformly moving Ants nothing actually happens until an Ant collides with another Ant or falls off the stick. For the set of all adjoining Ants we could calculate the minimum collision time and use it as the value of the next time step. This code (not yet tested) illustrates the idea:\r\n```\r\n\t/**\r\n\t * Determine if two Ants will collide with each other,\r\n\t * and if so, calculate how long until it happens.\r\n\t * \r\n\t * @param other another Ant object\r\n\t * @return number of seconds until the two Ants collide.\r\n\t * If ants are moving in opposite directions then\r\n\t * the collision occurred in the past, so it is valid\r\n\t * to return a negative number.\r\n\t * If ants are moving in the same direction then\r\n\t * there won't be a collision. Indicate this by\r\n\t * returning a large negative number.\r\n\t */\r\n\tpublic double timeToCollision(Ant otherAnt) {\r\n\r\n\t\tdouble deltaV = otherAnt.getV() - getV() ;\r\n\t\tdouble deltaX = otherAnt.getX() - getX();\r\n\t\tif( Math.abs(deltaV) < epsV ) {\r\n\t\t\t// the ants are moving in the same direction\r\n\t\t\treturn -100.0/epsV;\r\n\t\t} else {\r\n\t\t\treturn -deltaX/deltaV;\r\n\t\t}\r\n\t}\r\n```\r\n\r\n\r\n\r\n\r\n### Strategic Ants\r\nWe know we have to deal with Ants that move on a line segment and also with Ants that move on a ring. Calculating the distance between two Ants will be different: a pair of Ants on the line at positions 1.0 and 99.0 are 98.0 cm. apart, but on the ring they are both 98.0 and 2.0 cm. apart, depending on direction. It would be nice to apply this as an external strategy, but is it possible?\r\n\r\n### Generic Ants\r\nWhere we consider if we can develop a generalized simulation for interacting actors. The simulation object would contain the actors and the global time. It would run by applying a step() operation to the actors, something like ```actor.evolve(timeStep)```. The key is whether we can usefully separate the simulation from the actors, without unduly constraining either.\r\n\r\n### Gold-plated Ants?\r\nWe could extend Ants to move in two dimensions, to have different velocities, to have different masses, to have a shape and size, etc. When is that a good idea, and when isn't it?\r\n\r\n### Other People's Ants\r\nWhere we consider other directions:\r\nDiscrete-event simulation\r\nPhysics engines for games\r\nBig simulation systems\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}